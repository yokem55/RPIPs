<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>diff</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="settings" content="whole_filler,use_css,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="none">
<style>
<!--
pre { font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Statement { color: #af5f00; }
.Type { color: #008000; }
.Identifier { color: #008080; }
.Special { color: #c000c0; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Folded { color: #0000c0; background-color: #a8a8a8; padding-bottom: 1px; }
.DiffAdd { background-color: #5fd7ff; padding-bottom: 1px; }
.DiffChange { background-color: #ffd7ff; padding-bottom: 1px; }
.DiffDelete { color: #8080ff; background-color: #afffff; padding-bottom: 1px; }
.DiffText { background-color: #ff6060; padding-bottom: 1px; font-weight: bold; }
-->
<!--
table { table-layout: fixed; }
html, body, table, tbody { width: 100%; margin: 0; padding: 0; }
table, td, th { border: 1px solid; }
td { vertical-align: top; }
th, td { width: 50.0%; }
td div { overflow: auto; }
-->
</style>
</head>
<body>
<table id='vimCodeElement'>
<tr>
<th>generator-impl-v8.go</th>
<th>generator-impl-v10.go</th>
</tr><tr>
<td><div>
<pre>
<span class="Folded">+-- 22 lines: package rewards---------------------------------------------------------------------------------------------------------------------</span>
	<span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/config&quot;</span>
	<span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/keys&quot;</span>
	sharedtypes <span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/types&quot;</span>
	<span class="Constant">&quot;golang.org/x/sync/errgroup&quot;</span>
)

<span class="Statement DiffText">var</span><span class="DiffText"> </span><span class="DiffText">six = big.NewInt(</span><span class="Constant DiffText">6</span><span class="DiffText">)</span><span class="DiffChange">                                                                                                                           </span>
<span class="DiffChange"> </span><span class="DiffChange">                                                                                                                                                 </span>
<span class="Comment DiffAdd">// Implementation for tree generator ruleset v8</span><span class="DiffAdd">                                                                                                   </span>
<span class="Statement DiffAdd">type</span><span class="DiffAdd"> treeGeneratorImpl_v8 </span><span class="Statement DiffAdd">struct</span><span class="DiffAdd"> {                                                                                                                </span>
	networkState           *state.NetworkState
	rewardsFile            *RewardsFile_v3
	elSnapshotHeader       *types.Header
	logger                 *slog.Logger
	rp                     *rocketpool.RocketPool
	cfg                    *config.SmartNodeConfig
<span class="Folded">+-- 14 lines: bc                     beacon.IBeaconClient-----------------------------------------------------------------------------------------</span>
	totalAttestationScore  *big.Int
	successfulAttestations <span class="Type">uint64</span>
	genesisTime            time.Time
}

<span class="Comment">// Create a new tree generator</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> newTreeGeneratorImpl_v</span><span class="DiffText">8(logger *slog.Logger, index </span><span class="Type DiffText">uint64</span><span class="DiffText">, startTime time.Time, endTime time.Time, consensusBlock </span><span class="Type DiffText">uint64</span><span class="DiffText">, elSnapshotHeader *types.Header, intervalsPassed </span><span class="Type DiffText">uint64</span><span class="DiffText">, state *state.NetworkState) *treeGeneratorImpl_v8</span><span class="DiffChange"> {</span>
<span class="DiffChange">	</span><span class="Statement DiffChange">return</span><span class="DiffChange"> &amp;treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">{                                                                                                             </span>
		rewardsFile: &amp;RewardsFile_v3{
			RewardsFileHeader: &amp;sharedtypes.RewardsFileHeader{
				RewardsFileVersion:  <span class="Constant">3</span>,
<span class="DiffChange">				RulesetVersion:      </span><span class="Constant DiffText">8</span><span class="DiffChange">,                                                                                           </span>
				Index:               index,
				StartTime:           startTime.UTC(),
				EndTime:             endTime.UTC(),
				ConsensusEndBlock:   consensusBlock,
				ExecutionEndBlock:   elSnapshotHeader.Number.Uint64(),
				IntervalsPassed:     intervalsPassed,
<span class="Folded">+-- 25 lines: InvalidNetworkNodes: map[common.Address]uint64{},-----------------------------------------------------------------------------------</span>
		totalAttestationScore: big.NewInt(<span class="Constant">0</span>),
		networkState:          state,
	}
}

<span class="Comment">// Get the version of the ruleset used by this generator</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) getRulesetVersion() </span><span class="Type DiffChange">uint64</span><span class="DiffChange"> {                                                                                       </span>
	<span class="Statement">return</span> r.rewardsFile.RulesetVersion
}

<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) generateTree(context context.Context, rp *rocketpool.RocketPool, cfg *config.SmartNodeConfig, bc beacon.IBeaconClient) (sharedtypes.IRewardsFile, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	r.logger.Info(<span class="Constant">&quot;Started rewards tree generation.&quot;</span>, slog.Uint64(keys.RulesetKey, r.rewardsFile.RulesetVersion))

	<span class="Comment">// Provision some struct params</span>
	r.rp = rp
	r.cfg = cfg
	r.bc = bc
<span class="Folded">+-- 58 lines: r.validNetworkCache = map[uint64]bool{----------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> r.rewardsFile, <span class="Constant">nil</span>
}

<span class="Comment">// Quickly calculates an approximate of the staker's share of the smoothing pool balance without processing Beacon performance</span>
<span class="Comment">// Used for approximate returns in the rETH ratio update</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) approximateStakerShareOfSmoothingPool(context context.Context, rp *rocketpool.RocketPool, cfg *config.SmartNodeConfig, bc beacon.IBeaconClient) (*big.Int, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	r.logger.Info(<span class="Constant">&quot;Approximating rewards tree.&quot;</span>, slog.Uint64(keys.RulesetKey, r.rewardsFile.RulesetVersion))

	r.rp = rp
	r.cfg = cfg
	r.bc = bc
	r.validNetworkCache = <span class="Type">map</span>[<span class="Type">uint64</span>]<span class="Type">bool</span>{
<span class="Folded">+-- 34 lines: 0: true,----------------------------------------------------------------------------------------------------------------------------</span>
	}

	<span class="Statement">return</span> &amp;r.rewardsFile.TotalRewards.PoolStakerSmoothingPoolEth.Int, <span class="Constant">nil</span>
}

<span class="Comment">// Calculates the per-network distribution amounts and the total reward amounts</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) updateNetworksAndTotals() {                                                                                        </span>
	<span class="Comment">// Get the highest network index with valid rewards</span>
	highestNetworkIndex := <span class="Type">uint64</span>(<span class="Constant">0</span>)
	<span class="Statement">for</span> network := <span class="Statement">range</span> r.rewardsFile.NetworkRewards {
		<span class="Statement">if</span> network &gt; highestNetworkIndex {
			highestNetworkIndex = network
		}
<span class="Folded">+-- 10 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
			}
			r.rewardsFile.NetworkRewards[network] = rewardsForNetwork
		}
	}
}

<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) calculateNodeRplRewards(                                                                                           </span>
	collateralRewards *big.Int,
	nodeEffectiveStake *big.Int,
	totalEffectiveRplStake *big.Int,
	nodeWeight *big.Int,
	totalNodeWeight *big.Int,
) *big.Int {
<span class="Folded">+-- 36 lines: if nodeEffectiveStake.Sign() &lt;= 0 || nodeWeight.Sign() &lt;= 0 {-----------------------------------------------------------------------</span>

	<span class="Comment">// Add them together</span>
	<span class="Statement">return</span> rpip30Rewards.Add(rpip30Rewards, oldRewards)
}

<span class="Comment">// Calculates the RPL rewards for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) calculateRplRewards() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                                      </span>
	pendingRewards := r.networkState.NetworkDetails.PendingRPLRewards
	r.logger.Info(<span class="Constant">&quot;Calculated Pending RPL rewards&quot;</span>, slog.String(keys.AmountKey, getRewardsString(pendingRewards)))
	<span class="Statement">if</span> pendingRewards.Cmp(common.Big0) == <span class="Constant">0</span> {
		<span class="Statement">return</span> fmt.Errorf(<span class="Constant">&quot;there are no pending RPL rewards, so this interval cannot be used for rewards submission&quot;</span>)
	}

<span class="Folded">+-- 43 lines: Get baseline Protocol DAO rewards---------------------------------------------------------------------------------------------------</span>
				totalNodeEffectiveStake,
				nodeWeights[nodeDetails.NodeAddress],
				totalNodeWeight,
			)

			<span class="Comment">// If there are pending rewards, add it to the map</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
			<span class="Statement">if</span> nodeRplRewards.Sign() == <span class="Constant">1</span> {
<span class="DiffChange">				rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[</span><span class="DiffText">nodeDetails.NodeAddress</span><span class="DiffChange">]                                </span>
				<span class="Statement">if</span> !exists {
					<span class="Comment">// Get the network the rewards should go to</span>
					network := r.networkState.NodeDetails[i].RewardNetwork.Uint64()
					validNetwork, err := r.validateNetwork(network)
					<span class="Statement">if</span> err != <span class="Constant">nil</span> {
						<span class="Statement">return</span> err
<span class="Folded">+--  6 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
					rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
						RewardNetwork:    network,
						CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
						OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
						SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					}
<span class="DiffChange">					r.rewardsFile.ClaimerRewards[</span><span class="DiffText">nodeDetails.NodeAddress</span><span class="DiffChange">] = rewardsForClaimer                                 </span>
				}
				rewardsForClaimer.CollateralRpl.Add(&amp;rewardsForClaimer.CollateralRpl.Int, nodeRplRewards)

				<span class="Comment">// Add the rewards to the running total for the specified network</span>
				rewardsForNetwork, exists := r.rewardsFile.NetworkRewards[rewardsForClaimer.RewardNetwork]
				<span class="Statement">if</span> !exists {
<span class="Folded">+-- 63 lines: rewardsForNetwork = &amp;sharedtypes.NetworkRewardsInfo{--------------------------------------------------------------------------------</span>

		<span class="Comment">// Calculate the oDAO rewards for the node: (participation time) * (total oDAO rewards) / (total participation time)</span>
		individualOdaoRewards := big.NewInt(<span class="Constant">0</span>)
		individualOdaoRewards.Mul(trueODaoNodeTimes[address], totalODaoRewards)
		individualOdaoRewards.Div(individualOdaoRewards, totalODaoNodeTime)

<span class="DiffChange">		</span><span class="DiffText">rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[address]</span><span class="DiffChange">                                                                </span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
		<span class="Statement">if</span> !exists {
			<span class="Comment">// Get the network the rewards should go to</span>
			network := r.networkState.NodeDetailsByAddress[address].RewardNetwork.Uint64()
			validNetwork, err := r.validateNetwork(network)
			<span class="Statement">if</span> err != <span class="Constant">nil</span> {
				<span class="Statement">return</span> err
<span class="Folded">+--  6 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
			rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
				RewardNetwork:    network,
				CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
			}
<span class="DiffChange">			r.rewardsFile.ClaimerRewards[</span><span class="DiffText">address</span><span class="DiffChange">] = rewardsForClaimer                                                                 </span>

		}
		rewardsForClaimer.OracleDaoRpl.Add(&amp;rewardsForClaimer.OracleDaoRpl.Int, individualOdaoRewards)

		<span class="Comment">// Add the rewards to the running total for the specified network</span>
		rewardsForNetwork, exists := r.rewardsFile.NetworkRewards[rewardsForClaimer.RewardNetwork]
<span class="Folded">+-- 30 lines: if !exists {------------------------------------------------------------------------------------------------------------------------</span>
	r.logger.Info(<span class="Constant">&quot;Calculated total node weight,&quot;</span>, slog.String(keys.TotalNodeWeightKey, totalNodeWeight.String()))

	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Calculates the ETH rewards for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) calculateEthRewards(context context.Context, checkBeaconPerformance </span><span class="Type DiffChange">bool</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                  </span>
	<span class="Comment">// Get the Smoothing Pool contract's balance</span>
	r.smoothingPoolBalance = r.networkState.NetworkDetails.SmoothingPoolBalance
	r.logger.Info(<span class="Constant">&quot;Retrieved Smoothing Pool balance&quot;</span>, slog.String(keys.AmountKey, getRewardsString(r.smoothingPoolBalance)))

	<span class="Comment">// Ignore the ETH calculation if there are no rewards</span>
	<span class="Statement">if</span> r.smoothingPoolBalance.Cmp(common.Big0) == <span class="Constant">0</span> {
<span class="Folded">+-- 79 lines: return nil--------------------------------------------------------------------------------------------------------------------------</span>
		<span class="Statement">return</span> err
	}

	<span class="Comment">// Update the rewards maps</span>
	<span class="Statement">for</span> _, nodeInfo := <span class="Statement">range</span> r.nodeDetails {
		<span class="Statement">if</span> nodeInfo.IsEligible &amp;&amp; nodeInfo.SmoothingPoolEth.Cmp(common.Big0) &gt; <span class="Constant">0</span> {
<span class="DiffChange">			</span><span class="DiffText">rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[nodeInfo.Address]</span><span class="DiffChange">                                               </span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
			<span class="Statement">if</span> !exists {
				network := nodeInfo.RewardsNetwork
				validNetwork, err := r.validateNetwork(network)
				<span class="Statement">if</span> err != <span class="Constant">nil</span> {
					<span class="Statement">return</span> err
				}
<span class="Folded">+--  5 lines: if !validNetwork {------------------------------------------------------------------------------------------------------------------</span>
				rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
					RewardNetwork:    network,
					CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				}
<span class="DiffChange">				r.rewardsFile.ClaimerRewards[</span><span class="DiffText">nodeInfo.Address</span><span class="DiffChange">] = rewardsForClaimer                                                </span>
			}
			rewardsForClaimer.SmoothingPoolEth.Add(&amp;rewardsForClaimer.SmoothingPoolEth.Int, nodeInfo.SmoothingPoolEth)

			<span class="Comment">// Add minipool rewards to the JSON</span>
			<span class="Statement">for</span> _, minipoolInfo := <span class="Statement">range</span> nodeInfo.Minipools {
				successfulAttestations := <span class="Type">uint64</span>(<span class="Identifier">len</span>(minipoolInfo.CompletedAttestations))
<span class="Folded">+-- 35 lines: missingAttestations := uint64(len(minipoolInfo.MissingAttestationSlots))------------------------------------------------------------</span>
	r.rewardsFile.TotalRewards.NodeOperatorSmoothingPoolEth.Int = *nodeOpEth
	r.rewardsFile.TotalRewards.TotalSmoothingPoolEth.Int = *r.smoothingPoolBalance
	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Calculate the distribution of Smoothing Pool ETH to each node</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) calculateNodeRewards() (*big.Int, *big.Int, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {                                                               </span>
	<span class="Comment">// If there weren't any successful attestations, everything goes to the pool stakers</span>
	<span class="Statement">if</span> r.totalAttestationScore.Cmp(common.Big0) == <span class="Constant">0</span> || r.successfulAttestations == <span class="Constant">0</span> {
		r.logger.Warn(<span class="Constant">&quot;Sending the whole smoothing pool balance to the pool stakers.&quot;</span>, slog.String(keys.TotalScoreKey, r.totalAttestationScore.String()), slog.Uint64(keys.SuccessfulAttestationsKey, r.successfulAttestations))
		<span class="Statement">return</span> r.smoothingPoolBalance, big.NewInt(<span class="Constant">0</span>), <span class="Constant">nil</span>
	}

<span class="Folded">+-- 43 lines: totalEthForMinipools := big.NewInt(0)-----------------------------------------------------------------------------------------------</span>
	r.logger.Info(<span class="Constant">&quot;Adjusted Pool Staker ETH to account for truncation&quot;</span>, slog.String(keys.AmountKey, truePoolStakerAmount.String()))

	<span class="Statement">return</span> truePoolStakerAmount, totalEthForMinipools, <span class="Constant">nil</span>
}

<span class="Comment">// Get all of the duties for a range of epochs</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) processAttestationsForInterval(context context.Context) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                    </span>
	startEpoch := r.rewardsFile.ConsensusStartBlock / r.beaconConfig.SlotsPerEpoch
	endEpoch := r.rewardsFile.ConsensusEndBlock / r.beaconConfig.SlotsPerEpoch

	<span class="Comment">// Determine the validator indices of each minipool</span>
	err := r.createMinipoolIndexMap()
	<span class="Statement">if</span> err != <span class="Constant">nil</span> {
<span class="Folded">+-- 30 lines: return err--------------------------------------------------------------------------------------------------------------------------</span>

	r.logger.Info(<span class="Constant">&quot;Finished participation check&quot;</span>, slog.Duration(keys.TotalElapsedKey, time.Since(reportStartTime)))
	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Process an epoch, optionally getting the duties for all eligible minipools in it and checking each one's attestation performance</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) processEpoch(context context.Context, getDuties </span><span class="Type DiffChange">bool</span><span class="DiffChange">, epoch </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                        </span>

	<span class="Comment">// Get the committee info and attestation records for this epoch</span>
	<span class="Statement">var</span> committeeData beacon.Committees
	attestationsPerSlot := <span class="Identifier">make</span>([][]beacon.AttestationInfo, r.slotsPerEpoch)
	<span class="Statement">var</span> wg errgroup.Group

<span class="Folded">+-- 45 lines: if getDuties {----------------------------------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Handle all of the attestations in the given slot</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) checkDutiesForSlot(attestations []beacon.AttestationInfo, slot </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                     </span>

	one := eth.EthToWei(<span class="Constant">1</span>)
	validatorReq := eth.EthToWei(<span class="Constant">32</span>)

	<span class="Comment">// Go through the attestations for the block</span>
	<span class="Statement">for</span> _, attestation := <span class="Statement">range</span> attestations {
<span class="Folded">+-- 51 lines: Get the RP committees for this attestation's slot and index-------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Maps out the attestaion duties for the given epoch</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) getDutiesForEpoch(committees beacon.Committees) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                            </span>

	<span class="Comment">// Crawl the committees</span>
	<span class="Statement">for</span> idx := <span class="Constant">0</span>; idx &lt; committees.Count(); idx++ {
		slotIndex := committees.Slot(idx)
		<span class="Statement">if</span> slotIndex &lt; r.rewardsFile.ConsensusStartBlock || slotIndex &gt; r.rewardsFile.ConsensusEndBlock {
			<span class="Comment">// Ignore slots that are out of bounds</span>
<span class="Folded">+-- 51 lines: continue----------------------------------------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Maps all minipools to their validator indices and creates a map of indices to minipool info</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) createMinipoolIndexMap() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                                   </span>

	<span class="Comment">// Get the status for all uncached minipool validators and add them to the cache</span>
	r.validatorIndexMap = <span class="Type">map</span>[<span class="Type">string</span>]*MinipoolInfo{}
	<span class="Statement">for</span> _, details := <span class="Statement">range</span> r.nodeDetails {
		<span class="Statement">if</span> details.IsEligible {
			<span class="Statement">for</span> _, minipoolInfo := <span class="Statement">range</span> details.Minipools {
<span class="Folded">+-- 41 lines: status, exists := r.networkState.ValidatorDetails[minipoolInfo.ValidatorPubkey]-----------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Get the details for every node that was opted into the Smoothing Pool for at least some portion of this interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) getSmoothingPoolNodeDetails() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                              </span>

	farFutureTime := time.Unix(<span class="Constant">1000000000000000000</span>, <span class="Constant">0</span>) <span class="Comment">// Far into the future</span>
	farPastTime := time.Unix(<span class="Constant">0</span>, <span class="Constant">0</span>)

	<span class="Comment">// For each NO, get their opt-in status and time of last change in batches</span>
	r.logger.Info(<span class="Constant">&quot;Getting details of nodes for Smoothing Pool calculation...&quot;</span>)
<span class="Folded">+-- 75 lines: nodeCount := uint64(len(r.networkState.NodeDetails))--------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Validates that the provided network is legal</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) validateNetwork(network </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) (</span><span class="Type DiffChange">bool</span><span class="DiffChange">, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {                                                                    </span>
	valid, exists := r.validNetworkCache[network]
	<span class="Statement">if</span> !exists {
		<span class="Comment">// Make the oDAO settings binding</span>
		oMgr, err := oracle.NewOracleDaoManager(r.rp)
		<span class="Statement">if</span> err != <span class="Constant">nil</span> {
			<span class="Statement">return</span> <span class="Constant">false</span>, fmt.Errorf(<span class="Constant">&quot;error creating oDAO manager binding: </span><span class="Special">%w</span><span class="Constant">&quot;</span>, err)
<span class="Folded">+-- 12 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
	}

	<span class="Statement">return</span> valid, <span class="Constant">nil</span>
}

<span class="Comment">// Gets the start blocks for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) getStartBlocksForInterval(context context.Context, previousIntervalEvent rewards.RewardsEvent) (*types.Header, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	<span class="Comment">// Sanity check to confirm the BN can access the block from the previous interval</span>
	_, exists, err := r.bc.GetBeaconBlock(context, previousIntervalEvent.ConsensusBlock.String())
	<span class="Statement">if</span> err != <span class="Constant">nil</span> {
		<span class="Statement">return</span> <span class="Constant">nil</span>, fmt.Errorf(<span class="Constant">&quot;error verifying block from previous interval: </span><span class="Special">%w</span><span class="Constant">&quot;</span>, err)
	}
	<span class="Statement">if</span> !exists {
<span class="Folded">+-- 41 lines: return nil, fmt.Errorf(&quot;couldn't retrieve CL block from previous interval (slot %d); this likely means you checkpoint sync'd your Beacon Node and it has not backfilled to the previous interval yet so it cannot be used for tree generation&quot;, previousIntervalEvent.ConsensusBlock.Uint64())</span>
	}

	<span class="Statement">return</span> startElHeader, <span class="Constant">nil</span>
}

<span class="Comment">// Get the bond and node fee of a minipool for the specified time</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">8</span><span class="DiffChange">) getMinipoolBondAndNodeFee(details *rpstate.NativeMinipoolDetails, blockTime time.Time) (*big.Int, *big.Int) {      </span>
	currentBond := details.NodeDepositBalance
	currentFee := details.NodeFee
	previousBond := details.LastBondReductionPrevValue
	previousFee := details.LastBondReductionPrevNodeFee

	<span class="Statement">var</span> reductionTimeBig *big.Int = details.LastBondReductionTime
<span class="Folded">+-- 17 lines: if reductionTimeBig.Cmp(common.Big0) == 0 {-----------------------------------------------------------------------------------------</span>
</pre>
</div></td>
<td><div>
<pre>
<span class="Folded">+-- 22 lines: package rewards---------------------------------------------------------------------------------------------------------------------</span>
	<span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/config&quot;</span>
	<span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/keys&quot;</span>
	sharedtypes <span class="Constant">&quot;github.com/rocket-pool/smartnode/v2/shared/types&quot;</span>
	<span class="Constant">&quot;golang.org/x/sync/errgroup&quot;</span>
)

<span class="Comment DiffText">// Implementation for tree generator ruleset v10</span><span class="DiffChange">                                                                                                  </span>
<span class="Statement DiffText">type</span><span class="DiffText"> treeGeneratorImpl_v10 </span><span class="Statement DiffText">struct</span><span class="DiffText"> {</span><span class="DiffChange">                                                                                                               </span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="DiffDelete">--------------------------------------------------------------------------------------------------------------------------------------------------</span>
	networkState           *state.NetworkState
	rewardsFile            *RewardsFile_v3
	elSnapshotHeader       *types.Header
	logger                 *slog.Logger
	rp                     *rocketpool.RocketPool
	cfg                    *config.SmartNodeConfig
<span class="Folded">+-- 14 lines: bc                     beacon.IBeaconClient-----------------------------------------------------------------------------------------</span>
	totalAttestationScore  *big.Int
	successfulAttestations <span class="Type">uint64</span>
	genesisTime            time.Time
}

<span class="Comment">// Create a new tree generator</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> newTreeGeneratorImpl_v</span><span class="DiffText">10(logger *slog.Logger, index </span><span class="Type DiffText">uint64</span><span class="DiffText">, startTime time.Time, endTime time.Time, consensusBlock </span><span class="Type DiffText">uint64</span><span class="DiffText">, elSnapshotHeader *types.Header, intervalsPassed </span><span class="Type DiffText">uint64</span><span class="DiffText">, state *state.NetworkState) *treeGeneratorImpl_v10</span><span class="DiffChange"> {</span>
<span class="DiffChange">	</span><span class="Statement DiffChange">return</span><span class="DiffChange"> &amp;treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">{                                                                                                            </span>
		rewardsFile: &amp;RewardsFile_v3{
			RewardsFileHeader: &amp;sharedtypes.RewardsFileHeader{
				RewardsFileVersion:  <span class="Constant">3</span>,
<span class="DiffChange">				RulesetVersion:      </span><span class="Constant DiffText">10</span><span class="DiffChange">,                                                                                          </span>
				Index:               index,
				StartTime:           startTime.UTC(),
				EndTime:             endTime.UTC(),
				ConsensusEndBlock:   consensusBlock,
				ExecutionEndBlock:   elSnapshotHeader.Number.Uint64(),
				IntervalsPassed:     intervalsPassed,
<span class="Folded">+-- 25 lines: InvalidNetworkNodes: map[common.Address]uint64{},-----------------------------------------------------------------------------------</span>
		totalAttestationScore: big.NewInt(<span class="Constant">0</span>),
		networkState:          state,
	}
}

<span class="Comment">// Get the version of the ruleset used by this generator</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) getRulesetVersion() </span><span class="Type DiffChange">uint64</span><span class="DiffChange"> {                                                                                      </span>
	<span class="Statement">return</span> r.rewardsFile.RulesetVersion
}

<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) generateTree(context context.Context, rp *rocketpool.RocketPool, cfg *config.SmartNodeConfig, bc beacon.IBeaconClient) (sharedtypes.IRewardsFile, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	r.logger.Info(<span class="Constant">&quot;Started rewards tree generation.&quot;</span>, slog.Uint64(keys.RulesetKey, r.rewardsFile.RulesetVersion))

	<span class="Comment">// Provision some struct params</span>
	r.rp = rp
	r.cfg = cfg
	r.bc = bc
<span class="Folded">+-- 58 lines: r.validNetworkCache = map[uint64]bool{----------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> r.rewardsFile, <span class="Constant">nil</span>
}

<span class="Comment">// Quickly calculates an approximate of the staker's share of the smoothing pool balance without processing Beacon performance</span>
<span class="Comment">// Used for approximate returns in the rETH ratio update</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) approximateStakerShareOfSmoothingPool(context context.Context, rp *rocketpool.RocketPool, cfg *config.SmartNodeConfig, bc beacon.IBeaconClient) (*big.Int, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	r.logger.Info(<span class="Constant">&quot;Approximating rewards tree.&quot;</span>, slog.Uint64(keys.RulesetKey, r.rewardsFile.RulesetVersion))

	r.rp = rp
	r.cfg = cfg
	r.bc = bc
	r.validNetworkCache = <span class="Type">map</span>[<span class="Type">uint64</span>]<span class="Type">bool</span>{
<span class="Folded">+-- 34 lines: 0: true,----------------------------------------------------------------------------------------------------------------------------</span>
	}

	<span class="Statement">return</span> &amp;r.rewardsFile.TotalRewards.PoolStakerSmoothingPoolEth.Int, <span class="Constant">nil</span>
}

<span class="Comment">// Calculates the per-network distribution amounts and the total reward amounts</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) updateNetworksAndTotals() {                                                                                       </span>
	<span class="Comment">// Get the highest network index with valid rewards</span>
	highestNetworkIndex := <span class="Type">uint64</span>(<span class="Constant">0</span>)
	<span class="Statement">for</span> network := <span class="Statement">range</span> r.rewardsFile.NetworkRewards {
		<span class="Statement">if</span> network &gt; highestNetworkIndex {
			highestNetworkIndex = network
		}
<span class="Folded">+-- 10 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
			}
			r.rewardsFile.NetworkRewards[network] = rewardsForNetwork
		}
	}
}

<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) calculateNodeRplRewards(                                                                                          </span>
	collateralRewards *big.Int,
	nodeEffectiveStake *big.Int,
	totalEffectiveRplStake *big.Int,
	nodeWeight *big.Int,
	totalNodeWeight *big.Int,
) *big.Int {
<span class="Folded">+-- 36 lines: if nodeEffectiveStake.Sign() &lt;= 0 || nodeWeight.Sign() &lt;= 0 {-----------------------------------------------------------------------</span>

	<span class="Comment">// Add them together</span>
	<span class="Statement">return</span> rpip30Rewards.Add(rpip30Rewards, oldRewards)
}

<span class="Comment">// Calculates the RPL rewards for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) calculateRplRewards() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                                     </span>
	pendingRewards := r.networkState.NetworkDetails.PendingRPLRewards
	r.logger.Info(<span class="Constant">&quot;Calculated Pending RPL rewards&quot;</span>, slog.String(keys.AmountKey, getRewardsString(pendingRewards)))
	<span class="Statement">if</span> pendingRewards.Cmp(common.Big0) == <span class="Constant">0</span> {
		<span class="Statement">return</span> fmt.Errorf(<span class="Constant">&quot;there are no pending RPL rewards, so this interval cannot be used for rewards submission&quot;</span>)
	}

<span class="Folded">+-- 43 lines: Get baseline Protocol DAO rewards---------------------------------------------------------------------------------------------------</span>
				totalNodeEffectiveStake,
				nodeWeights[nodeDetails.NodeAddress],
				totalNodeWeight,
			)

			<span class="Comment">// If there are pending rewards, add it to the map</span>
<span class="DiffAdd">			claimer := nodeDetails.NodeAddress</span><span class="DiffAdd">                                                                                        </span>
<span class="DiffAdd">			</span><span class="Statement DiffAdd">if</span><span class="DiffAdd"> nodeDetails.IsRplWithdrawalAddressSet &amp;&amp; nodeDetails.PrimaryWithdrawalAddress != nodeDetails.NodeAddress {             </span>
<span class="DiffAdd">				</span><span class="Comment DiffAdd">// Add it to the RPL withdrawal address if set</span><span class="DiffAdd">                                                                    </span>
<span class="DiffAdd">				claimer = nodeDetails.RplWithdrawalAddress</span><span class="DiffAdd">                                                                        </span>
<span class="DiffAdd">			}</span><span class="DiffAdd">                                                                                                                         </span>
			<span class="Statement">if</span> nodeRplRewards.Sign() == <span class="Constant">1</span> {
<span class="DiffChange">				rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[</span><span class="DiffText">claimer</span><span class="DiffChange">]                                                </span>
				<span class="Statement">if</span> !exists {
					<span class="Comment">// Get the network the rewards should go to</span>
					network := r.networkState.NodeDetails[i].RewardNetwork.Uint64()
					validNetwork, err := r.validateNetwork(network)
					<span class="Statement">if</span> err != <span class="Constant">nil</span> {
						<span class="Statement">return</span> err
<span class="Folded">+--  6 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
					rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
						RewardNetwork:    network,
						CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
						OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
						SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					}
<span class="DiffChange">					r.rewardsFile.ClaimerRewards[</span><span class="DiffText">claimer</span><span class="DiffChange">] = rewardsForClaimer                                                 </span>
				}
				rewardsForClaimer.CollateralRpl.Add(&amp;rewardsForClaimer.CollateralRpl.Int, nodeRplRewards)

				<span class="Comment">// Add the rewards to the running total for the specified network</span>
				rewardsForNetwork, exists := r.rewardsFile.NetworkRewards[rewardsForClaimer.RewardNetwork]
				<span class="Statement">if</span> !exists {
<span class="Folded">+-- 63 lines: rewardsForNetwork = &amp;sharedtypes.NetworkRewardsInfo{--------------------------------------------------------------------------------</span>

		<span class="Comment">// Calculate the oDAO rewards for the node: (participation time) * (total oDAO rewards) / (total participation time)</span>
		individualOdaoRewards := big.NewInt(<span class="Constant">0</span>)
		individualOdaoRewards.Mul(trueODaoNodeTimes[address], totalODaoRewards)
		individualOdaoRewards.Div(individualOdaoRewards, totalODaoNodeTime)

<span class="DiffChange">		</span><span class="DiffText">claimer := address</span><span class="DiffChange">                                                                                                                </span>
<span class="DiffAdd">		node := r.networkState.NodeDetailsByAddress[address]</span><span class="DiffAdd">                                                                              </span>
<span class="DiffAdd">		</span><span class="Statement DiffAdd">if</span><span class="DiffAdd"> node.IsRplWithdrawalAddressSet &amp;&amp; node.PrimaryWithdrawalAddress != node.NodeAddress {                                          </span>
<span class="DiffAdd">			</span><span class="Comment DiffAdd">// Add it to the RPL withdrawal address if set</span><span class="DiffAdd">                                                                            </span>
<span class="DiffAdd">			claimer = node.RplWithdrawalAddress</span><span class="DiffAdd">                                                                                       </span>
<span class="DiffAdd">		}</span><span class="DiffAdd">                                                                                                                                 </span>
<span class="DiffAdd">		rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[claimer]</span><span class="DiffAdd">                                                                </span>
		<span class="Statement">if</span> !exists {
			<span class="Comment">// Get the network the rewards should go to</span>
			network := r.networkState.NodeDetailsByAddress[address].RewardNetwork.Uint64()
			validNetwork, err := r.validateNetwork(network)
			<span class="Statement">if</span> err != <span class="Constant">nil</span> {
				<span class="Statement">return</span> err
<span class="Folded">+--  6 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
			rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
				RewardNetwork:    network,
				CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
			}
<span class="DiffChange">			r.rewardsFile.ClaimerRewards[</span><span class="DiffText">claimer</span><span class="DiffChange">] = rewardsForClaimer                                                                 </span>

		}
		rewardsForClaimer.OracleDaoRpl.Add(&amp;rewardsForClaimer.OracleDaoRpl.Int, individualOdaoRewards)

		<span class="Comment">// Add the rewards to the running total for the specified network</span>
		rewardsForNetwork, exists := r.rewardsFile.NetworkRewards[rewardsForClaimer.RewardNetwork]
<span class="Folded">+-- 30 lines: if !exists {------------------------------------------------------------------------------------------------------------------------</span>
	r.logger.Info(<span class="Constant">&quot;Calculated total node weight,&quot;</span>, slog.String(keys.TotalNodeWeightKey, totalNodeWeight.String()))

	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Calculates the ETH rewards for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) calculateEthRewards(context context.Context, checkBeaconPerformance </span><span class="Type DiffChange">bool</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                 </span>
	<span class="Comment">// Get the Smoothing Pool contract's balance</span>
	r.smoothingPoolBalance = r.networkState.NetworkDetails.SmoothingPoolBalance
	r.logger.Info(<span class="Constant">&quot;Retrieved Smoothing Pool balance&quot;</span>, slog.String(keys.AmountKey, getRewardsString(r.smoothingPoolBalance)))

	<span class="Comment">// Ignore the ETH calculation if there are no rewards</span>
	<span class="Statement">if</span> r.smoothingPoolBalance.Cmp(common.Big0) == <span class="Constant">0</span> {
<span class="Folded">+-- 79 lines: return nil--------------------------------------------------------------------------------------------------------------------------</span>
		<span class="Statement">return</span> err
	}

	<span class="Comment">// Update the rewards maps</span>
	<span class="Statement">for</span> _, nodeInfo := <span class="Statement">range</span> r.nodeDetails {
		<span class="Statement">if</span> nodeInfo.IsEligible &amp;&amp; nodeInfo.SmoothingPoolEth.Cmp(common.Big0) &gt; <span class="Constant">0</span> {
<span class="DiffChange">			</span><span class="DiffText">claimer := nodeInfo.Address</span><span class="DiffChange">                                                                                               </span>
<span class="DiffAdd">			node := r.networkState.NodeDetailsByAddress[nodeInfo.Address]</span><span class="DiffAdd">                                                             </span>
<span class="DiffAdd">			</span><span class="Statement DiffAdd">if</span><span class="DiffAdd"> node.IsRplWithdrawalAddressSet &amp;&amp; node.PrimaryWithdrawalAddress != node.NodeAddress {                                  </span>
<span class="DiffAdd">				</span><span class="Comment DiffAdd">// Add the ETH to the primary withdrawal address if the RPL withdrawal address is set</span><span class="DiffAdd">                             </span>
<span class="DiffAdd">				claimer = node.PrimaryWithdrawalAddress</span><span class="DiffAdd">                                                                           </span>
<span class="DiffAdd">			}</span><span class="DiffAdd">                                                                                                                         </span>
<span class="DiffAdd"> </span><span class="DiffAdd">                                                                                                                                                 </span>
<span class="DiffAdd">			rewardsForClaimer, exists := r.rewardsFile.ClaimerRewards[claimer]</span><span class="DiffAdd">                                                        </span>
			<span class="Statement">if</span> !exists {
				network := nodeInfo.RewardsNetwork
				validNetwork, err := r.validateNetwork(network)
				<span class="Statement">if</span> err != <span class="Constant">nil</span> {
					<span class="Statement">return</span> err
				}
<span class="Folded">+--  5 lines: if !validNetwork {------------------------------------------------------------------------------------------------------------------</span>
				rewardsForClaimer = &amp;ClaimerRewardsInfo_v3{
					RewardNetwork:    network,
					CollateralRpl:    sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					OracleDaoRpl:     sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
					SmoothingPoolEth: sharedtypes.NewQuotedBigInt(<span class="Constant">0</span>),
				}
<span class="DiffChange">				r.rewardsFile.ClaimerRewards[</span><span class="DiffText">claimer</span><span class="DiffChange">] = rewardsForClaimer                                                         </span>
			}
			rewardsForClaimer.SmoothingPoolEth.Add(&amp;rewardsForClaimer.SmoothingPoolEth.Int, nodeInfo.SmoothingPoolEth)

			<span class="Comment">// Add minipool rewards to the JSON</span>
			<span class="Statement">for</span> _, minipoolInfo := <span class="Statement">range</span> nodeInfo.Minipools {
				successfulAttestations := <span class="Type">uint64</span>(<span class="Identifier">len</span>(minipoolInfo.CompletedAttestations))
<span class="Folded">+-- 35 lines: missingAttestations := uint64(len(minipoolInfo.MissingAttestationSlots))------------------------------------------------------------</span>
	r.rewardsFile.TotalRewards.NodeOperatorSmoothingPoolEth.Int = *nodeOpEth
	r.rewardsFile.TotalRewards.TotalSmoothingPoolEth.Int = *r.smoothingPoolBalance
	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Calculate the distribution of Smoothing Pool ETH to each node</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) calculateNodeRewards() (*big.Int, *big.Int, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {                                                              </span>
	<span class="Comment">// If there weren't any successful attestations, everything goes to the pool stakers</span>
	<span class="Statement">if</span> r.totalAttestationScore.Cmp(common.Big0) == <span class="Constant">0</span> || r.successfulAttestations == <span class="Constant">0</span> {
		r.logger.Warn(<span class="Constant">&quot;Sending the whole smoothing pool balance to the pool stakers.&quot;</span>, slog.String(keys.TotalScoreKey, r.totalAttestationScore.String()), slog.Uint64(keys.SuccessfulAttestationsKey, r.successfulAttestations))
		<span class="Statement">return</span> r.smoothingPoolBalance, big.NewInt(<span class="Constant">0</span>), <span class="Constant">nil</span>
	}

<span class="Folded">+-- 43 lines: totalEthForMinipools := big.NewInt(0)-----------------------------------------------------------------------------------------------</span>
	r.logger.Info(<span class="Constant">&quot;Adjusted Pool Staker ETH to account for truncation&quot;</span>, slog.String(keys.AmountKey, truePoolStakerAmount.String()))

	<span class="Statement">return</span> truePoolStakerAmount, totalEthForMinipools, <span class="Constant">nil</span>
}

<span class="Comment">// Get all of the duties for a range of epochs</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) processAttestationsForInterval(context context.Context) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                   </span>
	startEpoch := r.rewardsFile.ConsensusStartBlock / r.beaconConfig.SlotsPerEpoch
	endEpoch := r.rewardsFile.ConsensusEndBlock / r.beaconConfig.SlotsPerEpoch

	<span class="Comment">// Determine the validator indices of each minipool</span>
	err := r.createMinipoolIndexMap()
	<span class="Statement">if</span> err != <span class="Constant">nil</span> {
<span class="Folded">+-- 30 lines: return err--------------------------------------------------------------------------------------------------------------------------</span>

	r.logger.Info(<span class="Constant">&quot;Finished participation check&quot;</span>, slog.Duration(keys.TotalElapsedKey, time.Since(reportStartTime)))
	<span class="Statement">return</span> <span class="Constant">nil</span>
}

<span class="Comment">// Process an epoch, optionally getting the duties for all eligible minipools in it and checking each one's attestation performance</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) processEpoch(context context.Context, getDuties </span><span class="Type DiffChange">bool</span><span class="DiffChange">, epoch </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                       </span>

	<span class="Comment">// Get the committee info and attestation records for this epoch</span>
	<span class="Statement">var</span> committeeData beacon.Committees
	attestationsPerSlot := <span class="Identifier">make</span>([][]beacon.AttestationInfo, r.slotsPerEpoch)
	<span class="Statement">var</span> wg errgroup.Group

<span class="Folded">+-- 45 lines: if getDuties {----------------------------------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Handle all of the attestations in the given slot</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) checkDutiesForSlot(attestations []beacon.AttestationInfo, slot </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                    </span>

	one := eth.EthToWei(<span class="Constant">1</span>)
	validatorReq := eth.EthToWei(<span class="Constant">32</span>)

	<span class="Comment">// Go through the attestations for the block</span>
	<span class="Statement">for</span> _, attestation := <span class="Statement">range</span> attestations {
<span class="Folded">+-- 51 lines: Get the RP committees for this attestation's slot and index-------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Maps out the attestaion duties for the given epoch</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) getDutiesForEpoch(committees beacon.Committees) </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                           </span>

	<span class="Comment">// Crawl the committees</span>
	<span class="Statement">for</span> idx := <span class="Constant">0</span>; idx &lt; committees.Count(); idx++ {
		slotIndex := committees.Slot(idx)
		<span class="Statement">if</span> slotIndex &lt; r.rewardsFile.ConsensusStartBlock || slotIndex &gt; r.rewardsFile.ConsensusEndBlock {
			<span class="Comment">// Ignore slots that are out of bounds</span>
<span class="Folded">+-- 51 lines: continue----------------------------------------------------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Maps all minipools to their validator indices and creates a map of indices to minipool info</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) createMinipoolIndexMap() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                                  </span>

	<span class="Comment">// Get the status for all uncached minipool validators and add them to the cache</span>
	r.validatorIndexMap = <span class="Type">map</span>[<span class="Type">string</span>]*MinipoolInfo{}
	<span class="Statement">for</span> _, details := <span class="Statement">range</span> r.nodeDetails {
		<span class="Statement">if</span> details.IsEligible {
			<span class="Statement">for</span> _, minipoolInfo := <span class="Statement">range</span> details.Minipools {
<span class="Folded">+-- 41 lines: status, exists := r.networkState.ValidatorDetails[minipoolInfo.ValidatorPubkey]-----------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Get the details for every node that was opted into the Smoothing Pool for at least some portion of this interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) getSmoothingPoolNodeDetails() </span><span class="Type DiffChange">error</span><span class="DiffChange"> {                                                                             </span>

	farFutureTime := time.Unix(<span class="Constant">1000000000000000000</span>, <span class="Constant">0</span>) <span class="Comment">// Far into the future</span>
	farPastTime := time.Unix(<span class="Constant">0</span>, <span class="Constant">0</span>)

	<span class="Comment">// For each NO, get their opt-in status and time of last change in batches</span>
	r.logger.Info(<span class="Constant">&quot;Getting details of nodes for Smoothing Pool calculation...&quot;</span>)
<span class="Folded">+-- 75 lines: nodeCount := uint64(len(r.networkState.NodeDetails))--------------------------------------------------------------------------------</span>

	<span class="Statement">return</span> <span class="Constant">nil</span>

}

<span class="Comment">// Validates that the provided network is legal</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) validateNetwork(network </span><span class="Type DiffChange">uint64</span><span class="DiffChange">) (</span><span class="Type DiffChange">bool</span><span class="DiffChange">, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {                                                                   </span>
	valid, exists := r.validNetworkCache[network]
	<span class="Statement">if</span> !exists {
		<span class="Comment">// Make the oDAO settings binding</span>
		oMgr, err := oracle.NewOracleDaoManager(r.rp)
		<span class="Statement">if</span> err != <span class="Constant">nil</span> {
			<span class="Statement">return</span> <span class="Constant">false</span>, fmt.Errorf(<span class="Constant">&quot;error creating oDAO manager binding: </span><span class="Special">%w</span><span class="Constant">&quot;</span>, err)
<span class="Folded">+-- 12 lines: }-----------------------------------------------------------------------------------------------------------------------------------</span>
	}

	<span class="Statement">return</span> valid, <span class="Constant">nil</span>
}

<span class="Comment">// Gets the start blocks for the given interval</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) getStartBlocksForInterval(context context.Context, previousIntervalEvent rewards.RewardsEvent) (*types.Header, </span><span class="Type DiffChange">error</span><span class="DiffChange">) {</span>
	<span class="Comment">// Sanity check to confirm the BN can access the block from the previous interval</span>
	_, exists, err := r.bc.GetBeaconBlock(context, previousIntervalEvent.ConsensusBlock.String())
	<span class="Statement">if</span> err != <span class="Constant">nil</span> {
		<span class="Statement">return</span> <span class="Constant">nil</span>, fmt.Errorf(<span class="Constant">&quot;error verifying block from previous interval: </span><span class="Special">%w</span><span class="Constant">&quot;</span>, err)
	}
	<span class="Statement">if</span> !exists {
<span class="Folded">+-- 41 lines: return nil, fmt.Errorf(&quot;couldn't retrieve CL block from previous interval (slot %d); this likely means you checkpoint sync'd your Beacon Node and it has not backfilled to the previous interval yet so it cannot be used for tree generation&quot;, previousIntervalEvent.ConsensusBlock.Uint64())</span>
	}

	<span class="Statement">return</span> startElHeader, <span class="Constant">nil</span>
}

<span class="Comment">// Get the bond and node fee of a minipool for the specified time</span>
<span class="Statement DiffChange">func</span><span class="DiffChange"> (r *treeGeneratorImpl_v</span><span class="DiffText">10</span><span class="DiffChange">) getMinipoolBondAndNodeFee(details *rpstate.NativeMinipoolDetails, blockTime time.Time) (*big.Int, *big.Int) {     </span>
	currentBond := details.NodeDepositBalance
	currentFee := details.NodeFee
	previousBond := details.LastBondReductionPrevValue
	previousFee := details.LastBondReductionPrevNodeFee

	<span class="Statement">var</span> reductionTimeBig *big.Int = details.LastBondReductionTime
<span class="Folded">+-- 17 lines: if reductionTimeBig.Cmp(common.Big0) == 0 {-----------------------------------------------------------------------------------------</span>
</pre>
</div></td>
</tr>
</table>
</body>
</html>
<!-- vim: set foldmethod=manual : -->

